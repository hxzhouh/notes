>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的[二叉树](https://baike.baidu.com/item/二叉树/1602879)： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为[二叉排序树](https://baike.baidu.com/item/二叉排序树/10905079)。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。 [1] 
>
>​                                                                                                               --百度百科 [二叉搜索树](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)

首先看一道 [leetcode](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

题目的意思是将有序链表转成搜索二叉树。正因为是 有序的，所以只要找到他的中间节点，小于中间节点的都在左边，大于中间节点的都在右边。

``` go
func sortedListToBST(head *ListNode) *TreeNode {
	if head == nil {
		return nil
	}
	mid := findMiddle(head) 获取中间节点作为第一个根
	node := &TreeNode{
		Val: mid.Val,
	}

	if head == mid { 只有一个节点
		return node
	}

	node.Left = sortedListToBST(head)
	node.Right = sortedListToBST(mid.Next)
	return node
}

func findMiddle(node *ListNode) *ListNode {
	var prev *ListNode
	slow, fast := node, node
	for fast != nil && fast.Next != nil { //end or end.Next
		prev = slow
		slow = slow.Next      //move 1
		fast = fast.Next.Next //move 2
	}

	if prev != nil {
		prev.Next = nil
	}
	return slow // = length/2 + 1
}
```

