> 本文翻译自 [The Go Memory Model](https://golang.org/ref/mem)

# 介绍

Go内存模型限定了一些条件 满足这些条件 才能让变量 安全地在不同的goroutine之间读写。

# 建议

程序如果要修改由多个goroutines 访问的数据，必须要序列化此类访问。

要序列化访问，请使用 `channel` 操作或其他同步原语（例如`sync`和`sync/atomic`包中的那些）来保护数据。

如果您必须阅读本文档的其余部分才能理解程序的行为，那么您就太聪明了。

别自作聪明

# Happens Before

在一个 goroutine中，读写操作必须按照一定的顺序执行。也就是说，只有在不改变goroutine 中语言定义的时候，才会对goroutine 进行重排序。也就是因为这种重排序。一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同。例如，如果一个goroutine执行a=1；b=2；，另一个goroutine可能会在更新a的值之前看到b的值。

为了指定读写操作的要求，我们定义了在 Go 程序中执行内存操作的部分顺序之前发生的事情。 如果事件 e1发生在事件 e2之前，那么我们说 e2发生在事件 e1之后。 而且，如果 e1在 e2之前没有发生，在 e2之后也没有发生，那么我们说 e1和 e2是同时发生的。

在单个goroutine 中，happens-before 就是程序所描述的顺序。

对v的写操作w 如果想被v的读操作r观察到 需要满足下面两个条件：

1.  r不发生在w之前
2. *r*. 没有其它的写操作w` 发生在w之后 r之前

想要保证读操作r 可以观察到特定的w写操作 需要确保w是r唯一可以观察到的写操作 也就是说 只有满足下面条件后 才得以保证r访问到w 

1. *w* happens before *r*.  
2.  任何其它对v的写 要么发生在w之前 要么在r之后

这两个条件要比之前的两个条件更加严苛 它需要没有其它的写操作和w或者r是并行发生的.

在单个goroutine中，没有并发问题。因此，两个定义可以认为是相等的，读操作r看到的是由最近的写操作w写入的值。当多个goroutine 访问同一个共享变量的时候，就必须使用同步事件来建立之前的条件，以确保读操作w正确访问到写操作r之后的值。

# 拓展阅读